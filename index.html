<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>proforprof.com – Remember kids…</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{
    --ps-green:#00ff57;         /* ProfSaves green (adjust if needed) */
    --outline:#000000;          /* black outline */
    --glow:#8affb1;             /* subtle green glow */
    --bg: #000;                 /* page background (kept black/transparent-friendly) */
    --term-green:#7CFC00;       /* terminal text */
    --term-dim:#2f6b2f;
    --caret:#7CFC00;
  }

  html,body{height:100%;margin:0;background:transparent;overflow:hidden}
  /* Stage container so we can swap to terminal after animations */
  #stage{position:fixed;inset:0;background:transparent}
  canvas{width:100vw;height:100vh;display:block}

  /* Terminal that appears after the animations */
  #terminal{
    position:fixed; inset:0;
    background: #000;           /* solid for readability; change to transparent if you want */
    color:var(--term-green);
    font: 16px/1.4 "Press Start 2P", monospace;
    padding: 32px;
    overflow:auto;
    display:none;
  }
  #terminal a{
    color:var(--term-green);
    text-decoration: none;
    border-bottom: 1px dotted var(--term-green);
  }
  #terminal a:hover{
    color:#b7ffb7;
    border-bottom-color:#b7ffb7;
  }
  .dim{ color: var(--term-dim); }
  .prompt::before{ content:"C:\\Prof> "; }
  .caret{
    display:inline-block; width: 0.75ch; margin-left:2px;
    background: var(--caret);
    animation: blink 1s steps(1,end) infinite;
  }
  @keyframes blink { 50% { background: transparent; } }
</style>
</head>
<body>
  <div id="stage">
    <canvas id="c"></canvas>
  </div>

  <div id="terminal" aria-live="polite"></div>

<script>
(() => {
  const CAN = document.getElementById('c');
  const CTX = CAN.getContext('2d');

  const LAYER = document.createElement('canvas');
  const LCTX  = LAYER.getContext('2d', { willReadFrequently: true });

  const TEXT = 'Remember kids...';
  const FONT = 'Press Start 2P';

  // Sequence timings (ms)
  const BLINKS = 5, BLINK_PERIOD = 800;
  const STAR_TIME = 6000;       // star erase duration
  const IMG_FADE_MS = 1200;     // fade-in for ProfSaves2.png
  const IMG_HOLD_MS = 800;      // small hold before star-out

  // Spin parameters
  const STAR_SPINS = 8;

  // State
  let bounds = {x:0,y:0,w:0,h:0,px:0};
  let t0;
  let phase = 0; // 0=blink,1=text star-out,2=image fade-in,3=image hold,4=image star-out,5=done->terminal
  let phaseStart = 0;
  let finished = false;

  // Image
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = "https://proforprof.com/profsaves/ProfSaves2.png";
  let imgReady = false;
  img.onload = () => { imgReady = true; if (phase >= 2) drawImageToLayer(); };

  function css(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }

  function resize(){
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    CAN.width  = Math.floor(CAN.clientWidth * dpr);
    CAN.height = Math.floor(CAN.clientHeight * dpr);
    CTX.setTransform(dpr,0,0,dpr,0,0);

    LAYER.width  = CAN.clientWidth;
    LAYER.height = CAN.clientHeight;
    LCTX.setTransform(1,0,0,1,0,0);

    if (phase <= 1) {
      drawTextLayer();
    } else if (imgReady) {
      drawImageToLayer();
    }
  }
  window.addEventListener('resize', resize, {passive:true});

  function drawTextLayer(){
    const W = LAYER.width, H = LAYER.height;
    const base = Math.min(W, H);
    const px = Math.max(28, Math.floor(base * 0.085));

    LCTX.clearRect(0,0,W,H);
    LCTX.font = `${px}px "${FONT}", monospace`;
    LCTX.textBaseline = 'alphabetic';

    const m = LCTX.measureText(TEXT);
    const textW = m.width;
    const textH = (m.actualBoundingBoxAscent || 0) + (m.actualBoundingBoxDescent || 0) || px*1.1;
    const x = Math.round((W - textW)/2);
    const y = Math.round((H + textH)/2 - textH*0.2);

    // Outline
    LCTX.lineJoin = 'round';
    LCTX.strokeStyle = css('--outline');
    LCTX.lineWidth   = Math.max(3, Math.round(px * 0.22));
    LCTX.strokeText(TEXT, x, y);

    // ProfSaves green fill
    const g = LCTX.createLinearGradient(0, y - textH, 0, y + textH);
    g.addColorStop(0, css('--ps-green'));
    g.addColorStop(1, css('--ps-green'));
    LCTX.fillStyle = g;
    LCTX.fillText(TEXT, x, y);

    // Subtle glow seed
    LCTX.save();
    LCTX.shadowColor = css('--glow');
    LCTX.shadowBlur  = 8;
    LCTX.fillRect(x, y - textH, 1, 1);
    LCTX.restore();

    bounds = { x, y, w:textW, h:textH, px };
  }

  function drawImageToLayer(){
    const W = LAYER.width, H = LAYER.height;
    LCTX.clearRect(0,0,W,H);

    if (!imgReady) return;

    // Contain-fit & center
    const scale = Math.min(W / img.width, H / img.height);
    const w = Math.round(img.width * scale);
    const h = Math.round(img.height * scale);
    const x = Math.round((W - w)/2);
    const y = Math.round((H - h)/2);

    LCTX.drawImage(img, x, y, w, h);

    // Save a simple "bounds" center reference for the spin
    bounds = { x, y: y + h, w, h, px: Math.max(16, Math.round(Math.min(W,H) * 0.06)) };
  }

  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

  function eraseWithSpinningStar(t){
    const { x, y, w, h, px } = bounds;
    const cx = x + w/2;
    const cy = phase <= 1 ? (y - h/2*0.1) : (y - h/2); // slight vertical tune: text vs image

    const angle = (Math.PI * 2) * (STAR_SPINS * t);
    const L = easeOutCubic(t);

    const fullLen = Math.sqrt(CAN.width*CAN.width + CAN.height*CAN.height);
    const lenNow  = fullLen * L;

    const barH = Math.max(3, Math.round(px * 0.09));

    LCTX.save();
    LCTX.globalCompositeOperation = 'destination-out';
    LCTX.translate(Math.round(cx), Math.round(cy));
    LCTX.rotate(angle);

    for (let i=0; i<5; i++){
      LCTX.save();
      LCTX.rotate(i * (2*Math.PI/5));
      const x0 = Math.round(-lenNow/2), y0 = Math.round(-barH/2);
      LCTX.fillStyle = '#000';
      LCTX.fillRect(x0, y0, Math.round(lenNow)+2, barH+2);
      LCTX.restore();
    }
    LCTX.restore();
  }

  function scrubTransparency(){
    const w = LAYER.width, h = LAYER.height;
    try {
      const img = LCTX.getImageData(0, 0, w, h);
      const d = img.data;
      for (let i = 0; i < d.length; i += 4) {
        if (d[i+3] < 8) { d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=0; }
      }
      LCTX.putImageData(img, 0, 0);
    } catch(e) {
      LCTX.clearRect(0, 0, w, h);
    }
  }

  function drawLayer(alpha=1){
    CTX.clearRect(0,0,CAN.clientWidth,CAN.clientHeight);
    if (alpha>0){
      CTX.globalAlpha = alpha;
      CTX.drawImage(LAYER, 0, 0);
      CTX.globalAlpha = 1;
    }
  }

  function nextPhase(now){
    phase++;
    phaseStart = now;
    if (phase === 2 && imgReady) drawImageToLayer();
  }

  function frame(now){
    if (!t0) { t0 = now; phaseStart = now; }

    if (phase === 0){
      const elapsed = now - phaseStart;
      const blinkEnd = BLINKS*BLINK_PERIOD;
      const phaseFrac = ((elapsed) % BLINK_PERIOD) / BLINK_PERIOD;
      drawLayer(phaseFrac < 0.5 ? 1 : 0);
      if (elapsed >= blinkEnd){ nextPhase(now); }
      requestAnimationFrame(frame);
      return;
    }

    if (phase === 1){
      const t = Math.min(1, (now - phaseStart) / STAR_TIME);
      eraseWithSpinningStar(t);
      drawLayer(1);
      if (t >= 1){ scrubTransparency(); nextPhase(now); }
      requestAnimationFrame(frame);
      return;
    }

    if (phase === 2){
      const t = Math.min(1, (now - phaseStart) / IMG_FADE_MS);
      drawLayer(t);
      if (t >= 1){ nextPhase(now); }
      requestAnimationFrame(frame);
      return;
    }

    if (phase === 3){
      drawLayer(1);
      if ((now - phaseStart) >= IMG_HOLD_MS){ nextPhase(now); }
      requestAnimationFrame(frame);
      return;
    }

    if (phase === 4){
      const t = Math.min(1, (now - phaseStart) / STAR_TIME);
      eraseWithSpinningStar(t);
      drawLayer(1);
      if (t >= 1){ scrubTransparency(); nextPhase(now); }
      requestAnimationFrame(frame);
      return;
    }

    if (phase === 5 && !finished){
      finished = true;
      document.getElementById('stage').style.display = 'none';
      startTerminal();
      return;
    }
  }

  document.fonts?.load(`16px "${FONT}"`).then(() => { resize(); requestAnimationFrame(frame); });
})();
</script>

<script>
/* ---------- Terminal + typing your links ---------- */
function startTerminal(){
  const term = document.getElementById('terminal');
  term.style.display = 'block';

  const links = [
    {label:"twitch", url:"https://twitch.tv/proforprof/"},
    {label:"home", url:"https://proforprof.com/"},
    {label:"ProfSaves downloads", url:"https://proforprof.com/profsaves/downloads.html"},
    {label:"Wikiprofia", url:"https://proforprof.com/wikiprofia/"},
    {label:"email", url:"mailto:proforprof@gmail.com"},
    {label:"Team Hitless project", url:"https://www.teamhitless.com/project/proforprof/"},
    {label:"Team Starborn", url:"https://www.twitch.tv/team/starborn"},
    {label:"Team CutieCo", url:"https://www.twitch.tv/team/cutieco"},
    {label:"The Firekeepers", url:"https://www.twitch.tv/team/thefirekeepers"}
  ];

  const lineElems = [];
  const caret = document.createElement('span'); caret.className = 'caret';

  function addPrompt(){
    const p = document.createElement('div');
    p.className = 'prompt';
    term.appendChild(p);
    lineElems.push(p);
    p.appendChild(caret);
    term.scrollTop = term.scrollHeight;
    return p;
  }

  function typeText(el, text, speed=10){
    return new Promise(resolve=>{
      let i=0;
      const tick = () => {
        if (i < text.length){
          caret.before(document.createTextNode(text.charAt(i++)));
          term.scrollTop = term.scrollHeight;
          setTimeout(tick, speed);
        } else resolve();
      };
      tick();
    });
  }

  function typeLink(el, label, url){
    return new Promise(resolve=>{
      const a = document.createElement('a');
      a.href = url; a.target = "_blank"; a.rel = "noopener";
      a.textContent = label + " -> " + url;
      caret.before(a);
      term.scrollTop = term.scrollHeight;
      setTimeout(resolve, 150);
    });
  }

  (async () => {
    const intro = document.createElement('div');
    intro.innerHTML = '<span class="dim">Initializing...</span>';
    term.appendChild(intro);
    await new Promise(r=>setTimeout(r,300));
    for (const {label,url} of links){
      const p = addPrompt();
      await typeText(p, label + '\n', 8);
      await typeLink(p, label, url);
      caret.remove(); p.appendChild(caret);
      await new Promise(r=>setTimeout(r, 150));
    }
    caret.remove();
    const done = document.createElement('div');
    done.className = 'dim';
    done.textContent = 'All links printed. Press Ctrl+L to clear.';
    term.appendChild(done);
    term.scrollTop = term.scrollHeight;
  })();
}
</script>
</body>
</html>
