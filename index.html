<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>This is not a site.</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{
    --ps-green:#00ff57;
    --outline:#ffffff;
    --glow:#bfbfbf;
    --term-green:#7CFC00;
    --caret:#7CFC00;
  }
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #stage{position:fixed;inset:0;background:#000}
  canvas{width:100vw;height:100vh;display:block}

  #terminal{
    position:fixed; inset:0;
    background:#000;
    color:var(--term-green);
    font:16px/1.4 "Press Start 2P", monospace;
    padding:32px;
    overflow:auto;
    display:none;
  }
  #terminal a{ color:var(--term-green); text-decoration:none; border-bottom:1px dotted var(--term-green); }
  #terminal a:hover{ color:#b7ffb7; border-bottom-color:#b7ffb7; }
  .prompt::before{ content:"C:\\Prof> "; color:#fff; }
  .caret{ display:inline-block;width:.75ch;margin-left:2px;background:var(--caret);animation:blink 1s steps(1,end) infinite; }
  @keyframes blink{50%{background:transparent}}
</style>
</head>
<body>
  <div id="stage"><canvas id="c"></canvas></div>
  <div id="terminal" aria-live="polite"></div>

<script>
(() => {
  const CAN = document.getElementById('c');
  const CTX = CAN.getContext('2d');
  const LAYER = document.createElement('canvas');
  const LCTX  = LAYER.getContext('2d', { willReadFrequently:true });

  const TEXT = 'Remember kids...';
  const FONT = 'Press Start 2P';

  // TEXT: long on-screen + slow dissolve (unchanged)
  const BLINKS = 5;
  const BLINK_PERIOD = 1000;
  const STAR_TIME_TEXT = 8000;

  // IMAGE: FAST APPEAR, LONGER HOLD, SLOWER DISSOLVE OUT
  const IMG_FADE_MS = 250;      // faster appearance
  const IMG_HOLD_MS = 1800;     // longer on-screen
  const STAR_TIME_IMG = 6000;   // slower dissolve out
  const STAR_SPINS = 8;

  let bounds = {x:0,y:0,w:0,h:0,px:0};
  let t0, phase=0, phaseStart=0, finished=false;

  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = "https://proforprof.com/profsaves/ProfSaves2.png";
  let imgReady = false;
  img.onload = () => { imgReady = true; if (phase >= 2) drawImageToLayer(); };

  function css(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }

  function resize(){
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    CAN.width  = Math.floor(CAN.clientWidth * dpr);
    CAN.height = Math.floor(CAN.clientHeight * dpr);
    CTX.setTransform(dpr,0,0,dpr,0,0);

    LAYER.width  = CAN.clientWidth;
    LAYER.height = CAN.clientHeight;
    LCTX.setTransform(1,0,0,1,0,0);

    if (phase <= 1) drawTextLayer();
    else if (imgReady) drawImageToLayer();
  }
  addEventListener('resize', resize, {passive:true});

  function drawTextLayer(){
    const W=LAYER.width, H=LAYER.height;
    const base = Math.min(W,H);
    const px = Math.max(28, Math.floor(base*0.085));

    LCTX.clearRect(0,0,W,H);
    LCTX.font = `${px}px "${FONT}", monospace`;
    LCTX.textBaseline = 'alphabetic';

    const m = LCTX.measureText(TEXT);
    const textW = m.width;
    const textH = (m.actualBoundingBoxAscent||0)+(m.actualBoundingBoxDescent||0) || px*1.1;
    const x = Math.round((W-textW)/2);
    const y = Math.round((H+textH)/2 - textH*0.2);

    LCTX.lineJoin='round';
    LCTX.strokeStyle = css('--outline');
    LCTX.lineWidth = Math.max(3, Math.round(px*0.22));
    LCTX.strokeText(TEXT,x,y);

    LCTX.fillStyle = css('--ps-green');
    LCTX.fillText(TEXT,x,y);

    LCTX.save(); LCTX.shadowColor=css('--glow'); LCTX.shadowBlur=6; LCTX.fillRect(x, y-textH, 1, 1); LCTX.restore();

    bounds = {x,y,w:textW,h:textH,px};
  }

  function drawImageToLayer(){
    const W=LAYER.width, H=LAYER.height;
    LCTX.clearRect(0,0,W,H);
    if (!imgReady) return;

    const s = Math.min(W/img.width, H/img.height);
    const w = Math.round(img.width*s);
    const h = Math.round(img.height*s);
    const x = Math.round((W-w)/2);
    const y = Math.round((H-h)/2);
    LCTX.drawImage(img,x,y,w,h);

    bounds = {x, y:y+h, w, h, px: Math.max(16, Math.round(Math.min(W,H)*0.06))};
  }

  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

  function eraseWithSpinningStar(t){
    const {x,y,w,h,px} = bounds;
    const cx = x + w/2;
    const cy = (phase <= 1) ? (y - h/2*0.1) : (y - h/2);

    const angle = (Math.PI*2) * (STAR_SPINS*t);
    const L = easeOutCubic(t);

    const fullLen = Math.sqrt(CAN.width*CAN.width + CAN.height*CAN.height);
    const lenNow  = fullLen * L;
    const barH = Math.max(3, Math.round(px*0.09));

    LCTX.save();
    LCTX.globalCompositeOperation='destination-out';
    LCTX.translate(Math.round(cx), Math.round(cy));
    LCTX.rotate(angle);
    for(let i=0;i<5;i++){
      LCTX.save(); LCTX.rotate(i*(2*Math.PI/5));
      const x0=Math.round(-lenNow/2), y0=Math.round(-barH/2);
      LCTX.fillStyle='#000'; LCTX.fillRect(x0,y0, Math.round(lenNow)+2, barH+2);
      LCTX.restore();
    }
    LCTX.restore();
  }

  function scrubTransparency(){
    const w=LAYER.width,h=LAYER.height;
    try{
      const im=LCTX.getImageData(0,0,w,h), d=im.data;
      for(let i=0;i<d.length;i+=4){ if(d[i+3]<8){ d[i]=d[i+1]=d[i+2]=d[i+3]=0; } }
      LCTX.putImageData(im,0,0);
    }catch(e){ LCTX.clearRect(0,0,w,h); }
  }

  function drawLayer(alpha=1){
    CTX.clearRect(0,0,CAN.clientWidth,CAN.clientHeight);
    if(alpha>0){ CTX.globalAlpha=alpha; CTX.drawImage(LAYER,0,0); CTX.globalAlpha=1; }
  }

  function nextPhase(now){ phase++; phaseStart=now; if(phase===2 && imgReady) drawImageToLayer(); }

  function frame(now){
    if(!t0){ t0=now; phaseStart=now; }

    if(phase===0){
      const elapsed = now - phaseStart;
      const blinkEnd = BLINKS*BLINK_PERIOD;
      const f = ((elapsed)%BLINK_PERIOD)/BLINK_PERIOD;
      drawLayer(f<0.5?1:0);
      if(elapsed>=blinkEnd) nextPhase(now);
      requestAnimationFrame(frame); return;
    }
    if(phase===1){ // slow text disintegration
      const t = Math.min(1,(now-phaseStart)/STAR_TIME_TEXT);
      eraseWithSpinningStar(t); drawLayer(1);
      if(t>=1){ scrubTransparency(); nextPhase(now); }
      requestAnimationFrame(frame); return;
    }
    if(phase===2){ // FAST image fade-in
      const t = Math.min(1,(now-phaseStart)/IMG_FADE_MS);
      drawLayer(t);
      if(t>=1) nextPhase(now);
      requestAnimationFrame(frame); return;
    }
    if(phase===3){ // LONGER HOLD
      drawLayer(1);
      if((now-phaseStart)>=IMG_HOLD_MS) nextPhase(now);
      requestAnimationFrame(frame); return;
    }
    if(phase===4){ // SLOWER image disintegration
      const t = Math.min(1,(now-phaseStart)/STAR_TIME_IMG);
      eraseWithSpinningStar(t); drawLayer(1);
      if(t>=1){ scrubTransparency(); nextPhase(now); }
      requestAnimationFrame(frame); return;
    }
    if(phase===5 && !finished){
      finished=true;
      document.getElementById('stage').style.display='none';
      startTerminal();
    }
  }

  document.fonts?.load(`16px "${FONT}"`).then(()=>{ resize(); requestAnimationFrame(frame); });
})();
</script>

<script>
function startTerminal(){
  const term = document.getElementById('terminal');
  term.style.display='block';

  const urls = [
    "https://twitch.tv/proforprof/",
    "https://proforprof.com/",
    "https://proforprof.com/profsaves/downloads.html",
    "https://proforprof.com/wikiprofia/",
    "mailto:proforprof@gmail.com",
    "https://www.teamhitless.com/project/proforprof/",
    "https://www.twitch.tv/team/starborn",
    "https://www.twitch.tv/team/cutieco",
    "https://www.twitch.tv/team/thefirekeepers"
  ];

  function addPrompt(){
    const row = document.createElement('div');
    row.className='prompt';
    term.appendChild(row);
    return row;
  }

  // one link per line with its own prompt
  for (const url of urls){
    const row = addPrompt();
    const a   = document.createElement('a');
    a.href=url; a.target="_blank"; a.rel="noopener"; a.textContent=url;
    row.appendChild(a);
  }
  term.scrollTop = term.scrollHeight;
}
</script>
</body>
</html>
